# Побитовые операции

Побитовые операции в C++ позволяют манипулировать отдельными битами данных.\
Эти операции выполняются на уровне битов и могут быть полезны для оптимизации\
кода, работы с флагами, шифрования и других задач.

##  Побитовое И (&)

Операция побитового И возвращает 1 только если оба соответствующих бита операндов равны 1.

### Таблица истинности для побитового И:

![image](https://github.com/user-attachments/assets/74cd84aa-96a9-4869-8f1f-e02ebf934df0)

```
int a = 5;    // 0101 в двоичном виде
int b = 3;    // 0011 в двоичном виде
int result = a & b;  // 0001 (1 в десятичном виде)
```
### Пример в C++:
```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101 в двоичном виде
    int b = 3;  // 0011 в двоичном виде
    int result = a & b;  // Побитовое И

    cout << "a & b = " << result << endl;  // 0001 (1 в десятичном виде)
    return 0;
}
```
### Свойства операции побитового И:

- Коммутативность: a & b = b & a
- Ассоциативность: a & (b & c) = (a & b) & c
- Свойство нуля: a & 0 = 0
- Свойство единицы: a & 1 = a (если a — 0 или 1)
- Идемпотентность: a & a = a

### Применение побитового И:

Проверка четности числа:\
Если младший бит числа равен 0, то число четное. Это можно проверить с помощью побитового И:

```
int number = 6;
if ((number & 1) == 0) {
    cout << "Число четное" << endl;
} else {
    cout << "Число нечетное" << endl;
}
```
Маскирование битов:\
Побитовое И используется для извлечения определенных битов из числа.\
Например, чтобы получить младшие 4 бита числа:
```
int number = 0x2F;  // 00101111 в двоичном виде
int mask = 0x0F;   // 00001111 в двоичном виде
int result = number & mask;  // 00001111 (15 в десятичном виде)
cout << "Результат: " << result << endl;
```
Управление флагами:
Побитовое И часто используется для проверки, установлен ли определенный флаг:
```
const int FLAG_A = 0x01;  // 0001
const int FLAG_B = 0x02;  // 0010
const int FLAG_C = 0x04;  // 0100

int flags = FLAG_A | FLAG_C;  // 0101

if (flags & FLAG_A) {
    cout << "Флаг A установлен" << endl;
}
if (flags & FLAG_B) {
    cout << "Флаг B установлен" << endl;
}
```

Очистка битов:
Побитовое И можно использовать для сброса (очистки) определенных битов:
```
int number = 0x2F;  // 00101111
int mask = 0xF0;    // 11110000
int result = number & mask;  // 00100000 (32 в десятичном виде)
cout << "Результат: " << result << endl;
```

Проверка, является ли число степенью двойки:
Если число является степенью двойки, то оно имеет только один бит, установленный в 1.\
Это можно проверить с помощью побитового И:
```
int number = 16;  // 00010000
if ((number & (number - 1)) == 0) {
    cout << "Число является степенью двойки" << endl;
} else {
    cout << "Число не является степенью двойки" << endl;
}
```

**Важно:**
Побитовое И работает только с целыми типами данных (int, char, long и т.д.).

Не путайте побитовое И (&) с логическим И (&&). Логическое И возвращает true или false, а побитовое И работает с битами.




## Побитовое ИЛИ (|)

Операция побитового ИЛИ возвращает 1 если хотя бы один из соответствующих битов операндов равен 1.

### Таблица истинности для побитового ИЛИ:

![image](https://github.com/user-attachments/assets/081978fc-cefa-45b1-b9aa-7d3aa342a849)

```
int a = 5;    // 0101
int b = 3;    // 0011
int result = a | b;  // 0111 (7 в десятичном виде)
```

### Пример в C++:
```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101 в двоичном виде
    int b = 3;  // 0011 в двоичном виде
    int result = a | b;  // Побитовое ИЛИ

    cout << "a | b = " << result << endl;  // 0111 (7 в десятичном виде)
    return 0;
}
```

### Свойства операции побитового ИЛИ:

- Коммутативность: a | b = b | a
- Ассоциативность: a | (b | c) = (a | b) | c
- Свойство нуля: a | 0 = a
- Свойство единицы: a | 1 = 1 (если a — 0 или 1)
- Идемпотентность: a | a = a

### Применение побитового ИЛИ:

Установка битов:\
Побитовое ИЛИ используется для установки определенных битов в 1.\
Например, чтобы установить младшие 4 бита числа:
```
int number = 0x20;  // 00100000 в двоичном виде
int mask = 0x0F;    // 00001111 в двоичном виде
int result = number | mask;  // 00101111 (47 в десятичном виде)
cout << "Результат: " << result << endl;
```
Комбинирование флагов:\
побитовое ИЛИ часто используется для комбинирования флагов:
```
const int FLAG_A = 0x01;  // 0001
const int FLAG_B = 0x02;  // 0010
const int FLAG_C = 0x04;  // 0100

int flags = FLAG_A | FLAG_B;  // 0011 (установлены флаги A и B)
cout << "Флаги: " << flags << endl;
```
Добавление битов:\
Побитовое ИЛИ можно использовать для добавления битов к числу:
```
int number = 0x10;  // 00010000
int mask = 0x01;    // 00000001
int result = number | mask;  // 00010001 (17 в десятичном виде)
cout << "Результат: " << result << endl;
```
Создание масок:\
Побитовое ИЛИ используется для создания масок, которые объединяют несколько битовых полей:
```
int mask = 0x01 | 0x02 | 0x04;  // 00000111 (7 в десятичном виде)
cout << "Маска: " << mask << endl;
```
***Важно:**
Побитовое ИЛИ работает только с целыми типами данных (int, char, long и т.д.).

Не путайте побитовое ИЛИ (|) с логическим ИЛИ (||). Логическое ИЛИ возвращает true или false, а побитовое ИЛИ работает с битами.

Пример с флагами:
```
#include <iostream>
using namespace std;

int main() {
    const int FLAG_A = 0x01;  // 0001
    const int FLAG_B = 0x02;  // 0010
    const int FLAG_C = 0x04;  // 0100

    int flags = FLAG_A | FLAG_C;  // 0101 (установлены флаги A и C)

    if (flags & FLAG_A) {
        cout << "Флаг A установлен" << endl;
    }
    if (flags & FLAG_B) {
        cout << "Флаг B установлен" << endl;
    }
    if (flags & FLAG_C) {
        cout << "Флаг C установлен" << endl;
    }

    return 0;
}
```

## Побитовое исключающее ИЛИ (^)

Операция побитового исключающего ИЛИ возвращает 1 если только один из соответствующих битов операндов равен 1.

### Таблица истинности для XOR:

![image](https://github.com/user-attachments/assets/531d8420-f810-4456-a6d9-ce4759e46d93)


```
int a = 5;    // 0101
int b = 3;    // 0011
int result = a ^ b;  // 0110 (6 в десятичном виде)
```
### Пример в C++:

```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101 в двоичном виде
    int b = 3;  // 0011 в двоичном виде
    int result = a ^ b;  // Побитовое XOR

    cout << "a ^ b = " << result << endl;  // 0110 (6 в десятичном виде)
    return 0;
}
```
### Свойства операции XOR:

 - Коммутативность: a ^ b = b ^ a
 - Ассоциативность: a ^ (b ^ c) = (a ^ b) ^ c
 - Свойство нуля: a ^ 0 = a
 - Свойство самонейтрализации: a ^ a = 0
 - Обратимость: Если a ^ b = c, то a ^ c = b и b ^ c = a.

### Применение XOR:

Обмен значений без временной переменной:
```
int a = 5, b = 10;
a = a ^ b;  // a = 5 ^ 10
b = a ^ b;  // b = (5 ^ 10) ^ 10 = 5
a = a ^ b;  // a = (5 ^ 10) ^ 5 = 10
cout << "a = " << a << ", b = " << b << endl;  // a = 10, b = 5
```

Шифрование:\
XOR используется в простых алгоритмах шифрования, так как он обратим.\
Например:
```
char message = 'A';  // Байт сообщения
char key = 0x1F;     // Ключ
char encrypted = message ^ key;  // Зашифрованное сообщение
char decrypted = encrypted ^ key;  // Расшифрованное сообщение
cout << "Original: " << message << ", Encrypted: " << encrypted << ", Decrypted: " << decrypted << endl;
```

Проверка на нечетность/четность:\
XOR можно использовать для быстрой проверки, является ли число нечетным:
```
int number = 7;
if (number ^ 1) {
    cout << "Число четное" << endl;
} else {
    cout << "Число нечетное" << endl;
}
```

Поиск уникального элемента в массиве:\
Если в массиве все элементы встречаются дважды, кроме одного,\
то XOR поможет найти уникальный элемент:
```
int arr[] = {2, 3, 4, 2, 3};
int unique = 0;
for (int i = 0; i < 5; i++) {
    unique ^= arr[i];
}
cout << "Уникальный элемент: " << unique << endl;  // 4
```

**Важно:**
XOR работает только с целыми типами данных (int, char, long и т.д.).\
Не путайте XOR с логическим ИЛИ (||) или побитовым ИЛИ (|).

## Побитовое НЕ (~)

Операция побитового НЕ инвертирует все биты операнда (меняет 0 на 1 и 1 на 0).

~~~
int a = 5;    // 0101
int result = ~a;  // 1010 (в зависимости от размера int, это будет большое отрицательное число)
~~~

## Побитовый сдвиг влево (<<)

Операция побитового сдвига влево сдвигает биты числа влево на указанное количество позиций.\
Освободившиеся биты заполняются нулями. Эта операция эквивалентна умножению числа на 
2^n, где n — количество позиций сдвига.

```
int a = 5;    // 0101
int result = a << 1;  // 1010 (10 в десятичном виде)
```

### Свойства побитового сдвига влево:

- Эквивалентность умножению на степень двойки:
a << n эквивалентно  a*2^n
Например, 5 << 2 эквивалентно 5×2^2=20

 - Заполнение нулями:\
При сдвиге влево освободившиеся биты справа всегда заполняются нулями.

 - Потеря данных:\
Если сдвиг приводит к выходу за пределы разрядности типа данных, старшие биты теряются.

### Применение побитового сдвига влево:

Быстрое умножение на степень двойки:
```
int a = 7;
int result = a << 3;  // 7 * 2^3 = 56
cout << "Результат: " << result << endl;
```

Создание масок:\
Побитовый сдвиг используется для создания масок. Например, чтобы создать маску с установленным\
n-м битом:
```
int n = 3;
int mask = 1 << n;  // 0001 << 3 = 1000 (8 в десятичном виде)
cout << "Маска: " << mask << endl;
```
Работа с битовыми флагами:\
Побитовый сдвиг используется для установки или проверки битовых флагов:
```
const int FLAG_A = 1 << 0;  // 0001
const int FLAG_B = 1 << 1;  // 0010
const int FLAG_C = 1 << 2;  // 0100

int flags = FLAG_A | FLAG_C;  // 0101 (установлены флаги A и C)
cout << "Флаги: " << flags << endl;
```
Оптимизация кода:\
Побитовый сдвиг влево часто используется в низкоуровневом\
программировании для оптимизации операций умножения.

**Важно:**
Побитовый сдвиг влево работает только с целыми типами данных (int, char, long и т.д.).\
Если сдвиг приводит к переполнению, результат зависит от типа данных и платформы.\

Пример использования:
```
#include <iostream>
using namespace std;

int main() {
    int a = 10;  // 1010 в двоичном виде
    int result = a << 2;  // 101000 (40 в десятичном виде)

    cout << "a << 2 = " << result << endl;
    return 0;
}
```
## Побитовый сдвиг вправо (>>)

Операция побитового сдвига вправо сдвигает биты числа вправо на указанное количество позиций.\
Освободившиеся биты заполняются нулями (для беззнаковых типов) или знаковым битом (для знаковых типов).

```
int a = 5;    // 0101
int result = a >> 1;  // 0010 (2 в десятичном виде)
```

## Пример использования побитовых операций:

```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101
    int b = 3;  // 0011

    cout << "a & b = " << (a & b) << endl;  // 1
    cout << "a | b = " << (a | b) << endl;  // 7
    cout << "a ^ b = " << (a ^ b) << endl;  // 6
    cout << "~a = " << ~a << endl;          // -6 (зависит от платформы)
    cout << "a << 1 = " << (a << 1) << endl;  // 10
    cout << "a >> 1 = " << (a >> 1) << endl;  // 2

    return 0;
}
```
## Применение побитовых операций:

 - Управление флагами: Побитовые операции часто используются для управления флагами (например, в системных вызовах или настройках).
 - Оптимизация: В некоторых случаях побитовые операции могут быть быстрее арифметических.
 - Шифрование и сжатие данных: Побитовые операции используются в алгоритмах шифрования и сжатия данных.

**Важно помнить, что побитовые операции работают только с целыми типами данных (int, char, long, и т.д.).**
