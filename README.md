# Побитовые операции

Побитовые операции в C++ позволяют манипулировать отдельными битами данных.\
Эти операции выполняются на уровне битов и могут быть полезны для оптимизации\
кода, работы с флагами, шифрования и других задач.

##  Побитовое И (&)

Операция побитового И возвращает 1 только если оба соответствующих бита операндов равны 1.

### Таблица истинности для побитового И:

![image](https://github.com/user-attachments/assets/74cd84aa-96a9-4869-8f1f-e02ebf934df0)

```
int a = 5;    // 0101 в двоичном виде
int b = 3;    // 0011 в двоичном виде
int result = a & b;  // 0001 (1 в десятичном виде)
```
### Пример в C++:
```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101 в двоичном виде
    int b = 3;  // 0011 в двоичном виде
    int result = a & b;  // Побитовое И

    cout << "a & b = " << result << endl;  // 0001 (1 в десятичном виде)
    return 0;
}
```
### Свойства операции побитового И:

- Коммутативность: a & b = b & a
- Ассоциативность: a & (b & c) = (a & b) & c
- Свойство нуля: a & 0 = 0
- Свойство единицы: a & 1 = a (если a — 0 или 1)
- Идемпотентность: a & a = a

### Применение побитового И:

Проверка четности числа:\
Если младший бит числа равен 0, то число четное. Это можно проверить с помощью побитового И:

```
int number = 6;
if ((number & 1) == 0) {
    cout << "Число четное" << endl;
} else {
    cout << "Число нечетное" << endl;
}
```
Маскирование битов:\
Побитовое И используется для извлечения определенных битов из числа.\
Например, чтобы получить младшие 4 бита числа:
```
int number = 0x2F;  // 00101111 в двоичном виде
int mask = 0x0F;   // 00001111 в двоичном виде
int result = number & mask;  // 00001111 (15 в десятичном виде)
cout << "Результат: " << result << endl;
```
Управление флагами:
Побитовое И часто используется для проверки, установлен ли определенный флаг:
```
const int FLAG_A = 0x01;  // 0001
const int FLAG_B = 0x02;  // 0010
const int FLAG_C = 0x04;  // 0100

int flags = FLAG_A | FLAG_C;  // 0101

if (flags & FLAG_A) {
    cout << "Флаг A установлен" << endl;
}
if (flags & FLAG_B) {
    cout << "Флаг B установлен" << endl;
}
```

Очистка битов:
Побитовое И можно использовать для сброса (очистки) определенных битов:
```
int number = 0x2F;  // 00101111
int mask = 0xF0;    // 11110000
int result = number & mask;  // 00100000 (32 в десятичном виде)
cout << "Результат: " << result << endl;
```

Проверка, является ли число степенью двойки:
Если число является степенью двойки, то оно имеет только один бит, установленный в 1.\
Это можно проверить с помощью побитового И:
```
int number = 16;  // 00010000
if ((number & (number - 1)) == 0) {
    cout << "Число является степенью двойки" << endl;
} else {
    cout << "Число не является степенью двойки" << endl;
}
```

**Важно:**
Побитовое И работает только с целыми типами данных (int, char, long и т.д.).

Не путайте побитовое И (&) с логическим И (&&). Логическое И возвращает true или false, а побитовое И работает с битами.




## Побитовое ИЛИ (|)

Операция побитового ИЛИ возвращает 1 если хотя бы один из соответствующих битов операндов равен 1.

```
int a = 5;    // 0101
int b = 3;    // 0011
int result = a | b;  // 0111 (7 в десятичном виде)
```

## Побитовое исключающее ИЛИ (^)

Операция побитового исключающего ИЛИ возвращает 1 если только один из соответствующих битов операндов равен 1.

### Таблица истинности для XOR:

![image](https://github.com/user-attachments/assets/531d8420-f810-4456-a6d9-ce4759e46d93)


```
int a = 5;    // 0101
int b = 3;    // 0011
int result = a ^ b;  // 0110 (6 в десятичном виде)
```
### Пример в C++:

```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101 в двоичном виде
    int b = 3;  // 0011 в двоичном виде
    int result = a ^ b;  // Побитовое XOR

    cout << "a ^ b = " << result << endl;  // 0110 (6 в десятичном виде)
    return 0;
}
```
### Свойства операции XOR:

 - Коммутативность: a ^ b = b ^ a
 - Ассоциативность: a ^ (b ^ c) = (a ^ b) ^ c
 - Свойство нуля: a ^ 0 = a
 - Свойство самонейтрализации: a ^ a = 0
 - Обратимость: Если a ^ b = c, то a ^ c = b и b ^ c = a.

### Применение XOR:

Обмен значений без временной переменной:
```
int a = 5, b = 10;
a = a ^ b;  // a = 5 ^ 10
b = a ^ b;  // b = (5 ^ 10) ^ 10 = 5
a = a ^ b;  // a = (5 ^ 10) ^ 5 = 10
cout << "a = " << a << ", b = " << b << endl;  // a = 10, b = 5
```

Шифрование:\
XOR используется в простых алгоритмах шифрования, так как он обратим.\
Например:
```
char message = 'A';  // Байт сообщения
char key = 0x1F;     // Ключ
char encrypted = message ^ key;  // Зашифрованное сообщение
char decrypted = encrypted ^ key;  // Расшифрованное сообщение
cout << "Original: " << message << ", Encrypted: " << encrypted << ", Decrypted: " << decrypted << endl;
```

Проверка на нечетность/четность:\
XOR можно использовать для быстрой проверки, является ли число нечетным:
```
int number = 7;
if (number ^ 1) {
    cout << "Число четное" << endl;
} else {
    cout << "Число нечетное" << endl;
}
```

Поиск уникального элемента в массиве:\
Если в массиве все элементы встречаются дважды, кроме одного,\
то XOR поможет найти уникальный элемент:
```
int arr[] = {2, 3, 4, 2, 3};
int unique = 0;
for (int i = 0; i < 5; i++) {
    unique ^= arr[i];
}
cout << "Уникальный элемент: " << unique << endl;  // 4
```

**Важно:**
XOR работает только с целыми типами данных (int, char, long и т.д.).\
Не путайте XOR с логическим ИЛИ (||) или побитовым ИЛИ (|).

## Побитовое НЕ (~)

Операция побитового НЕ инвертирует все биты операнда (меняет 0 на 1 и 1 на 0).

~~~
int a = 5;    // 0101
int result = ~a;  // 1010 (в зависимости от размера int, это будет большое отрицательное число)
~~~

## Побитовый сдвиг влево (<<)

Операция побитового сдвига влево сдвигает биты числа влево на указанное количество позиций. Освободившиеся биты заполняются нулями.

```
int a = 5;    // 0101
int result = a << 1;  // 1010 (10 в десятичном виде)
```

## Побитовый сдвиг вправо (>>)

Операция побитового сдвига вправо сдвигает биты числа вправо на указанное количество позиций.\
Освободившиеся биты заполняются нулями (для беззнаковых типов) или знаковым битом (для знаковых типов).

```
int a = 5;    // 0101
int result = a >> 1;  // 0010 (2 в десятичном виде)
```

## Пример использования побитовых операций:

```
#include <iostream>
using namespace std;

int main() {
    int a = 5;  // 0101
    int b = 3;  // 0011

    cout << "a & b = " << (a & b) << endl;  // 1
    cout << "a | b = " << (a | b) << endl;  // 7
    cout << "a ^ b = " << (a ^ b) << endl;  // 6
    cout << "~a = " << ~a << endl;          // -6 (зависит от платформы)
    cout << "a << 1 = " << (a << 1) << endl;  // 10
    cout << "a >> 1 = " << (a >> 1) << endl;  // 2

    return 0;
}
```
## Применение побитовых операций:

 - Управление флагами: Побитовые операции часто используются для управления флагами (например, в системных вызовах или настройках).
 - Оптимизация: В некоторых случаях побитовые операции могут быть быстрее арифметических.
 - Шифрование и сжатие данных: Побитовые операции используются в алгоритмах шифрования и сжатия данных.

**Важно помнить, что побитовые операции работают только с целыми типами данных (int, char, long, и т.д.).**
